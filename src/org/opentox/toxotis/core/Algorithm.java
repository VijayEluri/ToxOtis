package org.opentox.toxotis.core;

import com.hp.hpl.jena.datatypes.xsd.XSDDatatype;
import com.hp.hpl.jena.ontology.AnnotationProperty;
import com.hp.hpl.jena.ontology.Individual;
import com.hp.hpl.jena.ontology.OntModel;
import com.hp.hpl.jena.vocabulary.DC;
import java.net.URISyntaxException;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import org.opentox.toxotis.ToxOtisException;
import org.opentox.toxotis.client.VRI;
import org.opentox.toxotis.ontology.MetaInfo;
import org.opentox.toxotis.ontology.OntologicalClass;
import org.opentox.toxotis.ontology.collection.OTClasses;
import org.opentox.toxotis.ontology.collection.OTObjectProperties;
import org.opentox.toxotis.util.spiders.AlgorithmSpider;
import org.opentox.toxotis.util.spiders.TypedValue;

/**
 * Provides access to different types of algorithms. An algorithm object contains
 * very general metadata about an algorithm and in fact describes its input and
 * output requirements and gives information about its parametrization. The different
 * types of algorithms used in <a href="http://opentox.org">OpenTox</a> and the
 * connection to each other is formally established throught the 
 * <a href="http://opentox.org/dev/apis/api-1.1/Algorithms">OpenTox Algorithm Ontology</a>.
 *
 * @author Pantelis Sopasakis
 * @author Charalampos Chomenides
 */
public class Algorithm extends OTOnlineResource<Algorithm> {

    /** Set of parameters of the algorithm. Specify the way the algorithm is parametrized */
    private Set<Parameter> parameters = new HashSet<Parameter>();
    /** Set of ontological classes that characterize the algorithm*/
    private Collection<OntologicalClass> ontologies;

    /**
     * Create a new instance of Algorithm providing its identifier as a {@link VRI }.
     * @param uri
     *      The URI of the algorithm as a {@link VRI }.
     */
    public Algorithm(VRI uri) {
        super(uri);
    }

    public Algorithm(String uri) throws URISyntaxException {
        super(new VRI(uri));
    }

    /**
     * Get the ontological classes of the algorithm
     * @return
     *      The collection of ontological classes for this algorithm.
     */
    public Collection<OntologicalClass> getOntologies() {
        return ontologies;
    }

    /**
     * Specify the ontologies for this algorithm.
     * @param ontologies
     *      A collection of ontological classes that characterize this algorithm.
     */
    public void setOntologies(Collection<OntologicalClass> ontologies) {
        this.ontologies = ontologies;
    }

    /**
     * Retrieve the set of parameters for this algorithm.
     * @return
     *      Set of parameters
     */
    public Set<Parameter> getParameters() {
        return parameters;
    }

    public void setParameters(Set<Parameter> parameters) {
        this.parameters = parameters;
    }

    @Override
    public Individual asIndividual(OntModel model) {
        Individual indiv = model.createIndividual(getUri().getStringNoQuery(), OTClasses.Algorithm().inModel(model));
        indiv.addComment(model.createTypedLiteral("Representation automatically generated by YAQP-turbo.",
                XSDDatatype.XSDstring));

        final MetaInfo metaInfo = getMeta();
        if (metaInfo != null) {
            // rdfs:comment
            TypedValue<String> comment = metaInfo.getComment();
            if (comment != null) {
                indiv.addComment(model.createTypedLiteral(comment.getValue(), XSDDatatype.XSDstring));
            }

            // dc:title
            TypedValue<String> title = metaInfo.getTitle();
            if (title != null) {
                indiv.addLiteral(model.createAnnotationProperty(DC.title.getURI()),
                        model.createTypedLiteral(title.getValue(), XSDDatatype.XSDstring));
            }

            // dc:creator
            TypedValue<String> creator = metaInfo.getCreator();
            if (creator != null) {
                indiv.addLiteral(model.createAnnotationProperty(DC.creator.getURI()),
                        model.createTypedLiteral(creator.getValue(), XSDDatatype.XSDstring));
            }

            // dc:constributors
            Collection<TypedValue<String>> contributors = metaInfo.getContributors();
            if (contributors != null && !contributors.isEmpty()) {
                AnnotationProperty dc_contributor = model.createAnnotationProperty(DC.contributor.getURI());
                for (TypedValue<String> contributor : contributors) {
                    if (contributor != null) {
                        indiv.addLiteral(dc_contributor, model.createTypedLiteral(contributor.getValue(), XSDDatatype.XSDstring));
                    }
                }
            }

            TypedValue<String> identifier = metaInfo.getIdentifier();
            if (identifier != null) {
                // dc:identifier
                indiv.addLiteral(model.createAnnotationProperty(DC.identifier.getURI()),
                        model.createTypedLiteral(identifier.getValue(), XSDDatatype.XSDstring));
            }

            // dc:description
            TypedValue<String> description = metaInfo.getDescription();
            if (description != null) {
                indiv.addLiteral(model.createAnnotationProperty(DC.description.getURI()),
                        model.createTypedLiteral(description.getValue(), XSDDatatype.XSDstring));
            }

            TypedValue<String> publisher = metaInfo.getPublisher();
            if (publisher != null) {
                indiv.addLiteral(model.createAnnotationProperty(DC.publisher.getURI()),
                        model.createTypedLiteral(publisher.getValue(), XSDDatatype.XSDstring));
            }

            TypedValue<String> versionInfo = metaInfo.getVersionInfo();
            if (versionInfo != null) {
                indiv.setVersionInfo(versionInfo.getValue());
            }
        }
        if (ontologies != null && !ontologies.isEmpty()) {
            final Iterator<OntologicalClass> ontClassIter = ontologies.iterator();
            while (ontClassIter.hasNext()) {
                indiv.addRDFType(ontClassIter.next().inModel(model));
            }
        }
        if (parameters != null) {
            for (Parameter param : parameters) {
                indiv.addProperty(OTObjectProperties.parameters().asObjectProperty(model), param.asIndividual(model));
            }
        }
        return indiv;
    }

    @Override
    protected Algorithm loadFromRemote(VRI uri) throws ToxOtisException {
        AlgorithmSpider spider = new AlgorithmSpider(uri);
        Algorithm algorithm = spider.parse();
        setMeta(algorithm.getMeta());
        setOntologies(algorithm.getOntologies());
        setParameters(algorithm.getParameters());
        return this;
    }
}
